from docx import Document
from lxml import etree
from docx.opc.constants import RELATIONSHIP_TYPE as RT
import sys

# style_header is only provided as a reference, the actual resulting css is generated by generate_list_css()
style_header = '''
<!DOCTYPE html>
<!-- saved from url=(0068)file:///C:/Users/admin/Downloads/Telegram%20Desktop/basic_table.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <title>Sample Table - Basic Option</title>
    <style>
        li.nested-list-li {
            list-style-type: none;
            }
        ol{ counter-reset: list1; } /* Инициируем счетчик */
        ol li:before {
            counter-increment: list1; /* Увеличиваем значение счетчика */
            content: counter(list1) ". "; /* Выводим число */
        }
        ol ol { counter-reset: list2; } /* Инициируем счетчик вложенного списка */
        ol ol li:before {
            counter-increment: list2; /* Увеличиваем значение счетчика вложенного списка */
            content: counter(list1) "." counter(list2) ". "; /* Выводим число */
        }
        ol ol ol { counter-reset: list3; } /* Инициируем счетчик вложенного списка */
        ol ol ol li:before {
            counter-increment: list3; /* Увеличиваем значение счетчика вложенного списка */
            content: counter(list1) "." counter(list2) "." counter(list3) ". "; /* Выводим число */
        }
    </style>
</head>
'''
tab = '\t'


def init_io():
    current_doc = 'test.docx'
    output_file = 'result.html'
    dev_output = 'dbg.txt'
    if len(sys.argv) > 1:
        current_doc = sys.argv[1]
    if len(sys.argv) > 2:
        output_file = sys.argv[2]
    return current_doc, output_file, dev_output


def generate_list_css(max_nest):
    # this creates a css output based on the template stored in style_header for nested list representatipn
    ol = "ol "
    result = '<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">\n'
    result += '\t<style>\n'
    result += '\t\tli.nested-list-li {\n'
    result += '\t\t\tlist-style-type: none;'
    result += '\t\t\t}\n'
    for list_level in range(max_nest + 1):
        result += f"{tab * (2 + list_level)}{ol * (list_level + 1)}{{ counter-reset: list{(list_level + 1)};}}\n"
        result += f"{tab * (2 + list_level)}{ol * (list_level + 1)}li:before {{\n"
        result += f"{tab * (3 + list_level)}counter-increment: list{list_level + 1};\n"
        result += f"{tab * (3 + list_level)}content: " + "".join(
            [f"counter(list{i + 1}) \".\" " for i in range(list_level + 1)]) + f"\" \";\n{tab * (2 + list_level)}}}\n"
    result += '\t</style>\n</head>'
    return result


class list_node:
    def __init__(self, ilvl, value):
        self.value = value
        self.ilvl = ilvl

    def __repr__(self):
        return f"Level {self.ilvl}: " + self.value


class docx_list:
    def __init__(self, numid):
        self.nodes = []
        self.numid = numid

    def generate_list_html(self):
        result = ''
        # result += '\t<ol class="nested-list-ol">\n'
        current_node_ilvl = -1
        for node in self.nodes:
            if node.ilvl > current_node_ilvl:
                result += f'{tab * (node.ilvl + 1)}<ol class="nested-list-ol">\n'
                current_node_ilvl = node.ilvl
            if node.ilvl < current_node_ilvl:
                result += f'{tab * (node.ilvl + 1)}</ol>\n'
                current_node_ilvl = node.ilvl
            result += f'{tab * (node.ilvl + 2)}<li class="nested-list-li">{node.value}</li>\n'
        return result


def process_document():
    io = init_io()
    document = Document(io[0])
    rels = document.part.rels
    hyperlinks = {}
    for rel in rels:
        if rels[rel].reltype == RT.HYPERLINK:
            #print("\n Origianl link id -", rel, "with detected URL: ", rels[rel]._target)
            hyperlinks[rel] = rels[rel]._target
    document.save(io[0])
    document_xml = [para._p.xml for para in document.paragraphs]
    with open(io[2], 'w+', encoding='utf-8')  as dev_output:
        dev_output.write("\n".join(document_xml))
    all_numbered_lists = {}
    max_nested_level: int = -1
    for paragraph in document_xml:
        tree = etree.fromstring(paragraph)
        li_node = tree.xpath('//w:numPr/w:ilvl [@w:val]', namespaces=tree.nsmap)
        hyper_link_section = tree.xpath("//w:hyperlink[@r:id]", namespaces=tree.nsmap)
        #print(hyper_link_section)
        if li_node:
            list_node_ilvl = int(li_node[0].attrib['{' + tree.nsmap['w'] + '}val'])
            if list_node_ilvl > max_nested_level:
                max_nested_level = list_node_ilvl
            list_node_numid = (tree.xpath('//w:numPr/w:numId[@w:val]', namespaces=tree.nsmap))[0].attrib['{' + tree.nsmap['w'] + '}val']
            list_node_value = ''
            if hyper_link_section:
                for hyperlink in hyper_link_section:
                    rid_value = hyperlink.attrib['{' + tree.nsmap['r'] + '}id']
                    #[print(x.text) for x in hyperlink.xpath(".//w:t", namespaces=tree.nsmap)]
                    text_value = "".join([text_part.text for text_part in hyperlink.xpath(".//w:t", namespaces=tree.nsmap)])
                    list_node_value += f'<a href="{hyperlinks[rid_value]}" target=" blank">{text_value}</a>'
                    #print(x.attrib for x in hyperlink.xpath("//w:t", namespaces=tree.nsmap))
                    print(list_node_value + '\n')
            else:
                style_parts = tree.xpath('//w:r', namespaces=tree.nsmap)
                for part in style_parts:
                    text_part = "".join([val.text for val in part.xpath('.//w:t', namespaces=tree.nsmap)])
                    style_part = part.xpath(".//w:rPr", namespaces=tree.nsmap)
                    bold = style_part[0].xpath(".//w:b", namespaces=tree.nsmap)
                    italic = style_part[0].xpath(".//w:i", namespaces=tree.nsmap)
                    strucktrhough = style_part[0].xpath(".//w:strike", namespaces=tree.nsmap)

                    if bold:
                        text_part = '<strong>' + text_part + '</strong>'
                    if italic:
                        text_part = '<em>' + text_part + '</em>'
                    if strucktrhough:
                        text_part = '<strike>' + text_part + '</strike>'
                    #with open(io[2], 'a+', encoding='utf-8') as dev_output:
                    #    dev_output.write("\n" + text_part)
                    list_node_value += text_part
            if list_node_numid not in all_numbered_lists:
                all_numbered_lists[list_node_numid] = docx_list(list_node_numid)
            all_numbered_lists[list_node_numid].nodes.append(list_node(list_node_ilvl, list_node_value))
    resulting_html = ''
    for li in all_numbered_lists:
        resulting_html += (all_numbered_lists[li].generate_list_html())

    with open(io[1], 'w+', encoding='utf-8') as output:
        output.write(generate_list_css(max_nested_level) + '<body>\n' + resulting_html + '\n</body>')


if __name__ == '__main__':
    process_document()
